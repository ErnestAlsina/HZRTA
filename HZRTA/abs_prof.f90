MODULE abs_prof
!-----------------------------------------------------------------------
USE global_vars
USE parameters
USE math
USE profile
!------------------------------------------------------------------------------------
IMPLICIT NONE
!------------------------------------------------------------------------------------
CONTAINS
!------------------------------------------------------------------------------------
!====================================================================================
SUBROUTINE prof_2L(x0)
!------------------------------------------------------------------------------------
! Calculates the line absorption profile at each height and frequency 
! in the observer's frame: prof_vo(iz,i) [s].
! This profile is in general complex, so we will consider both the real
! (Voigt profile) and imaginary (Faraday-Voigt) parts. 
! In the presence of a magnetic field we have Zeeman splitting, so we 
! will indicate each of the lines generated by this splitting by an 
! in index. For J_u=3/2 -> J_l=1/2 we have six different lines.
! Voigt: prof_vo(in,iz,i) [s]. 
! Faraday-Voigt: prof_fa(in,iz,i) [s]
!
! In this work, we neglect lower level polarization. If we take the
! positive direction of Q to be perpendicular or parallel to the limb 
! then eta_U and rho_U will be zero. Stimulated emission is also neglected.
!
! Calculates the quantity x0 [cm^2 s^-1] appearing in the expression of
! the frequency-integrated absorption coef. k_l=x0*N_l [cm^-1 s^-1] 
! with N_l [cm^-3] the number density of atoms in the lower level.
! The absorption coefficient for the intensity is finally given by 
! etaI_l=k_l*prof_vo [cm^-1].
!
! Calculates the weights uj needed for integrating in frequency with 
! trapezoidal rule.
!------------------------------------------------------------------------------------
  INTEGER :: i, iz, mu2,ml2,ll2,lu2,sl2,su2
  INTEGER :: hnorm
  DOUBLE PRECISION, INTENT(OUT) :: x0
  DOUBLE PRECISION :: ae, enerl, eneru
  DOUBLE PRECISION :: arg, phi, psi
  DOUBLE PRECISION :: norm, mnorm, dnorm
!-------
! nz, nwl, nu0, Aul, ad(nz), dnd(nz), nu(nwl), uj(nwl) :: global_vars
! prof_vo(nz,nwl) :: global_vars
!=======================================================================
!== CALCULATE WEIGHTS uj ===============================================
!=======================================================================
  allocate(uj(1:nwl)) !frequency weights for 
  uj(1)=0.5d0*dabs(nu(2)-nu(1))
  uj(nwl)=0.5d0*dabs(nu(nwl)-nu(nwl-1))
  do i=2,nwl-1
    uj(i)=0.5d0*dabs(nu(i+1)-nu(i-1))
  enddo
!=======================================================================
!== READ ATOMIC DATA ===================================================
!=======================================================================
  open(unit=1,file='isot_2L.dat')
  read(1,*) ae
  read(1,*) jl2,ll2,sl2
  read(1,*) enerl
  read(1,*) ju2,lu2,su2
  read(1,*) eneru
  close(unit=1)
  nu0=eneru-enerl
 if(.not.((ju2 .eq. 3) .and. (jl2 .eq.1))) print*, 'Transition!!'
allocate(prof_vo(-ju2:ju2,-jl2:jl2,1:nz,1:nwl),prof_fa(-ju2:ju2,-jl2:jl2,1:nz,1:nwl))
!=======================================================================
!== CALCULATE x0 =======================================================
!=======================================================================
  x0=Aul*(dble(ju2+1)/dble(jl2+1))*(pc**2)/(8.d0*pi*nu0**2)
!=======================================================================
!== CALCULATE ABSORPTION PROFILE(S) =======================================
!=======================================================================
do mu2=-ju2,ju2,2
 do ml2=-jl2,jl2,2
  do i=1,nwl
   do iz=1,nz
    prof_vo(mu2,ml2,iz,i) = 0.d0
    prof_fa(mu2,ml2,iz,i) = 0.d0
   enddo
  enddo 
 enddo
enddo
!
do mu2=-ju2,ju2,2 
 do ml2=-jl2,jl2,2
  if(abs(mu2-ml2).gt.2) CYCLE
  write(*,*) ml2,mu2,nular*0.5d0*(gu*dble(mu2)-gl*dble(ml2))
  do iz=1,nz
   do i=1,nwl
    arg=(nu0+nular*0.5d0*(gu*dble(mu2)-gl*dble(ml2))-nu(i))/dnd(iz)
    call profilarch(ad(iz),arg,phi,psi)!Voigt & Faraday prof.
    prof_vo(mu2,ml2,iz,i) = phi/(dsqrt(pi)*dnd(iz))
    prof_fa(mu2,ml2,iz,i) = psi/(dsqrt(pi)*dnd(iz))
   enddo !i
  enddo !iz
 enddo !ml2
enddo!mu2
!-----------------------------------------------------------------------
! Normalization
!-----------------------------------------------------------------------
! Normalizing each magnetic line separately
do mu2=-ju2,ju2,2
 do ml2 = -jl2,jl2,2
  if(abs(mu2-ml2).gt.2) CYCLE
  mnorm=0.d0
  hnorm=0
  do iz=1,nz
    norm=0.d0
    do i=1,nwl
      norm=norm+uj(i)*prof_vo(mu2,ml2,iz,i)
    enddo!i
    dnorm=dabs(1.d0-norm)
    if(dnorm.gt.mnorm) then
      mnorm=dnorm
      hnorm=iz
    endif
    do i=1,nwl
      prof_vo(mu2,ml2,iz,i) = prof_vo(mu2,ml2,iz,i)/norm
      prof_fa(mu2,ml2,iz,i) = prof_fa(mu2,ml2,iz,i)/norm
    enddo!i
  enddo!iz
 enddo!ml2
enddo !mu2
!-----------------------------------------------------------------------
  return
!-----------------------------------------------------------------------
END SUBROUTINE prof_2L
!===============================================================================


!===============================================================================
SUBROUTINE split(gu,gl,nular)
!--------------
! gu, gl, nular: global_vars
! dnul: global_vars
!--------------
DOUBLE PRECISION, INTENT(IN) :: gu,gl,nular
allocate(dnul(1:6))
dnul(1) = nular*(gu*1.5d0 - gl*0.5d0)
dnul(2) = nular*(gu*0.5d0 - gl*0.5d0)
dnul(3) = nular*(gu*0.5d0 + gl*0.5d0)
dnul(4) = nular*(-gu*0.5d0 - gl*0.5d0)
dnul(5) = nular*(-gu*0.5d0 + gl*0.5d0) 
dnul(6) = nular*(-gu*1.5d0 + gl*0.5d0)
!-------------
return
!-------------
END SUBROUTINE split
!==============================================================================

!==============================================================================
SUBROUTINE gener(re,im) 
!------------------------------------------------------------------------------
! Calculate the generalized profile
!------------------------------------------------------------------------------
DOUBLE PRECISION, INTENT(OUT) :: re(0:ju2,0:2,-2:2,nz,nwl), im(0:ju2,0:2,-2:2,nz,nwl)
INTEGER :: i,iz,ik,ikp,iq,mu1,mu2,ml,sq,sqp,amin, ina,inb
DOUBLE PRECISION :: fac,raiz,t1,t2
DOUBLE PRECISION,DIMENSION(:,:), allocatable :: c,d
!------------------------------------------------------------------------------
allocate(c(1:nz,1:nwl),d(1:nz,1:nwl))
call cpu_time(t1)
do ik=0,ju2! Loop over K
 do ikp=0,2! K'
  amin = MIN(ik,ikp)
  raiz = dsqrt(3.d0*DBLE((ju2+1)*(2*ik+1)*(2*ikp+1)))
  do iq = -2,2
   do iz = 1,nz
    do i=1,nwl
     c(iz,i) = 0.d0
     d(iz,i) = 0.d0
    enddo
   enddo
   if(amin.ge.iq) then 
    do ml = -jl2,jl2,2  !actually 2Ml
     do mu1 = -ju2,ju2,2 !actually 2Mu
      if(abs(mu1-ml).gt.2) CYCLE
      do mu2 = -ju2,ju2,2 !actually 2Mu'
       if(abs(mu2-ml).gt.2) CYCLE
       do sq = -2,2,2 !2*q
        if(sq.ne.(ml-mu1)) CYCLE
        do sqp =-2,2,2 !2*q'
         if(sqp.ne.(ml-mu2)) CYCLE
         fac= w3js(ju2,jl2,2,-mu1,ml,-sq)*w3js(ju2,jl2,2,-mu2,ml,-sqp)*&
          w3js(ju2,ju2,2*ik,mu2,-mu1,-2*iq)*w3js(2,2,2*ikp,sq,-sqp,-2*iq)
         if(MOD(2+ju2-mu1+sqp,2) .ne. 0) then
          print*, 'error'
          stop
         else if(MOD(2+ju2-mu1+sqp,4) .ne. 0) then
          fac = -fac
         endif
         do iz =1,nz
          do i=1,nwl 
           c(iz,i) = c(iz,i) + raiz*fac*0.5d0*(prof_vo(mu1,ml,iz,i) + prof_vo(mu2,ml,iz,i))
           d(iz,i) = d(iz,i) + raiz*fac*0.5d0*(prof_fa(mu1,ml,iz,i) - prof_fa(mu2,ml,iz,i)) 
          enddo!i
         enddo!iz 
        enddo !sqp
       enddo !sq
      enddo !mu2
     enddo !mu1
    enddo!ml
   endif
   do iz=1,nz
    do i=1,nwl
     re(ik,ikp,iq,iz,i) = c(iz,i)
     im(ik,ikp,iq,iz,i) = d(iz,i)
    enddo
   enddo
   print*, 'Ku,K,Q', ik,ikp,iq
  enddo !iq
 enddo !ikp
enddo !ik
!------------------------------------------------------------------------------
return
!------------------------------------------------------------------------------
END SUBROUTINE gener
!==============================================================================

!==============================================================================
SUBROUTINE etarho(k_l,eta_re,eta_im,rho_re,rho_im)
!------------------------------------------------------------------------------
! Calculates the eta and rho radiative transfer coefficients 
!------------------------------------------------------------------------------
DOUBLE PRECISION, INTENT(IN) :: k_l(nz)
DOUBLE PRECISION, INTENT(OUT) :: eta_re(0:3,nz,nwl,ndir,ndirx), eta_im(0:3,nz,nwl,ndir,ndirx) 
DOUBLE PRECISION, INTENT(OUT) :: rho_re(0:3,nz,nwl,ndir,ndirx), rho_im(0:3,nz,nwl,ndir,ndirx)
INTEGER :: i,iz,im,ax,k,q,sq,emu,eml,st, ind, j
DOUBLE PRECISION :: alph, beta, gam,fac, e,f
DOUBLE PRECISION, DIMENSION(0:2) :: raiz
DOUBLE PRECISION, DIMENSION(0:3) :: etre, etim, rore, roim, tst1,tst2, tst3,tst4
DOUBLE PRECISION, DIMENSION(0:3,0:2,1:ndir,1:ndirx) :: qre,qim
DOUBLE PRECISION, DIMENSION(0:2,-ju2:ju2,-jl2:jl2) :: factm
DOUBLE PRECISION, DIMENSION(0:2,1:nwl,1:nz) :: etfac, rofac
DOUBLE PRECISION :: t1,t2
gam = 0.d0
!---------------------------------------------------------------------------------
call cpu_time(t1)
do k=0,2
 do st = 0,3
  do im = 1,ndir
   do ax = 1,ndirx
   qre(st,k,im,ax) = 0.d0
   qim(st,k,im,ax) = 0.d0
   enddo!ax
  enddo!im 
 enddo!st
 do emu = -ju2,ju2,2
  do eml = -jl2,jl2,2
   factm(k,emu,eml) = 0.d0
  enddo!eml
 enddo!emu
enddo!k
!--------------------------------------------------------------------------------
do k=0,2
 raiz(k) = DSQRT(3.d0*(2.d0*DBLE(K)+1.d0))
 do im = 1,ndir
  do ax = 1,ndirx
   do st = 0,3
    do q = -k,k
     call comprod(TTR(k,q,st,im,ax),TTI(k,q,st,im,ax),DR(k,0,q),-DI(k,0,q),e,f)
     qre(st,k,im,ax) = qre(st,k,im,ax) + e
     qim(st,k,im,ax) = qim(st,k,im,ax) + f
    enddo!q
   enddo!st
  enddo!ax
 enddo!im
!  -----------------------   -----------------------   -----------------------
 do emu = -ju2,ju2,2
  do eml = -jl2,jl2,2
   if(abs(emu-eml).gt.2) CYCLE
   do sq = -2,2,2
    if(sq.ne.(eml-emu)) CYCLE
    fac = w3js(ju2,jl2,2,-emu,eml,-sq)*w3js(ju2,jl2,2,-emu,eml,-sq)*&
          w3js(2,2,2*k,sq,-sq,0)
    if(MOD(2+sq,4).ne.0) fac = -fac
    factm(k,emu,eml) = factm(k,emu,eml) + fac
   enddo!sq
  enddo!eml
 enddo!emu
enddo!k
!--------------------------------------------------------------------------------
do iz = 1,nz
 do i = 1,nwl
  do k = 0,2
   etfac(k,i,iz) = 0.d0
   rofac(k,i,iz) = 0.d0
   do emu = -ju2,ju2,2
    do eml = -jl2,jl2,2
     if(ABS(emu-eml).gt.2) CYCLE
      etfac(k,i,iz) = etfac(k,i,iz) + factm(k,emu,eml)*prof_vo(emu,eml,iz,i)!Real part of the profile
      rofac(k,i,iz) = rofac(k,i,iz) + factm(k,emu,eml)*prof_fa(emu,eml,iz,i)!Imaginary part of the profile
    enddo!k
   enddo!i
  enddo!iz
  do im = 1,ndir
   do ax = 1,ndirx
    do st = 0,3
     e = 0.d0
     f = 0.d0
     do k = 0,2
      e = e + raiz(k)*etfac(k,i,iz)*qre(st,k,im,ax)
      f = f + raiz(k)*rofac(k,i,iz)*qre(st,k,im,ax)     
     enddo!k
    eta_re(st,iz,i,im,ax) = k_l(iz)*e
    eta_im(st,iz,i,im,ax) = 0.d0
    rho_re(st,iz,i,im,ax) = k_l(iz)*f
    rho_im(st,iz,i,im,ax) = 0.d0
    enddo!st
   enddo!ax
  enddo!im
 enddo!i
enddo!iz
!
call cpu_time(t2)
print*, 'Radiative coefficient computation time:',t2-t1
!------------------------------------------------------------------------------
return
!------------------------------------------------------------------------------
END SUBROUTINE etarho
!==============================================================================

!==============================================================================
SUBROUTINE etasimple(k_l,TR,TI,eta_re,rho_re)
!------------------------------------------------------------------------------
! Calculates the eta and rho radiative transfer coefficients used to compute
!  the emergent radiation
!------------------------------------------------------------------------------
DOUBLE PRECISION, INTENT(IN) :: k_l(nz)
DOUBLE PRECISION, INTENT(IN) :: TR(0:2,-2:2,0:3), TI(0:2,-2:2,0:3)
DOUBLE PRECISION, INTENT(OUT) :: eta_re(0:3,nz,nwl), rho_re(0:3,nz,nwl)
INTEGER :: i,iz,k,q,sq,emu,eml,st, ind
DOUBLE PRECISION :: alph, beta, gam, fac,e,f
DOUBLE PRECISION, DIMENSION(0:2) :: raiz
DOUBLE PRECISION, DIMENSION(0:3) :: etre, etim, rore, rorim
DOUBLE PRECISION, DIMENSION(0:3,0:2) :: qre,qim
DOUBLE PRECISION, DIMENSION(0:2,-ju2:ju2,-jl2:jl2) :: factm
DOUBLE PRECISION, DIMENSION(0:2,1:nwl,1:nz) :: etfac, rofac
!------------------------------------------------------------------------------
gam = 0.d0
!------------------------------------------------------------------------------
do k=0,2
 do st = 0,3
   qre(st,k) = 0.d0
   qim(st,k) = 0.d0
 enddo
 do emu = -ju2,ju2,2
  do eml = -jl2,jl2,2
   factm(k,emu,eml) = 0.d0
  enddo
 enddo
enddo
!------------------------------------------------------------------------------
do k=0,2
 raiz(k) = DSQRT(3.d0*(2.d0*DBLE(K)+1.d0))
 do st = 0,3
  do q = -k,k
   call comprod(TR(k,q,st),TI(k,q,st),DR(k,0,q),-DI(k,0,q),e,f)
   qre(st,k) = qre(st,k) + e
   qim(st,k) = qim(st,k) + f
  enddo!q
 enddo!in
!  -----------------------   -----------------------   -----------------------
 do emu = -ju2,ju2,2
  do eml = -jl2,jl2,2
   if(abs(emu-eml).gt.2) CYCLE
   do sq = -2,2,2
    if(sq.ne.(eml-emu)) CYCLE
    fac = w3js(ju2,jl2,2,-emu,eml,-sq)*w3js(ju2,jl2,2,-emu,eml,-sq)*&
          w3js(2,2,2*k,sq,-sq,0)
    if(MOD(2+sq,4).ne.0) fac = -fac
    factm(k,emu,eml) = factm(k,emu,eml) + fac
   enddo!sq
  enddo!eml
 enddo!emu
enddo!k
!------------------------------------------------------------------------------
do iz = 1,nz
 do i = 1,nwl
  do k = 0,2
   etfac(k,i,iz) = 0.d0
   rofac(k,i,iz) = 0.d0
   do emu = -ju2,ju2,2
    do eml = -jl2,jl2,2
     IF(ABS(emu-eml).gt.2) CYCLE
      etfac(k,i,iz) = etfac(k,i,iz) + factm(k,emu,eml)*prof_vo(emu,eml,iz,i)!Real part of the profile
      rofac(k,i,iz) = rofac(k,i,iz) + factm(k,emu,eml)*prof_fa(emu,eml,iz,i)!Imaginary part of the profile
    enddo!eml
   enddo!emu
  enddo!k
  do st = 0,3
   e = 0.d0
   f = 0.d0
   do k = 0,2
    e = e + raiz(k)*etfac(k,i,iz)*qre(st,k)
    f = f + raiz(k)*rofac(k,i,iz)*qre(st,k)     
   enddo!k
   eta_re(st,iz,i) = k_l(iz)*e
   rho_re(st,iz,i) = k_l(iz)*f
  enddo!in
 enddo!i
enddo!iz
!------------------------------------------------------------------------------
return
!------------------------------------------------------------------------------
END SUBROUTINE etasimple
!==============================================================================


!!==============================================================================
!FUNCTION ZemInd(nmu,nml)
!!------------------------------------------------------------------------------
!! Gives the index asociated to Zeeman splitting
!! according to the input 2*M_u and 2*M_l
!!------------------------------------------------------------------------------
!INTEGER :: ZemInd
!INTEGER, INTENT(IN) :: nmu, nml
!!------------------------------------------------------------------------------
!ZemInd = 0
!if((nmu .eq. 3) .and. (nml .eq. 1)) ZemInd = 1
!if((nmu .eq. 1) .and. (nml .eq. 1)) ZemInd = 2
!if((nmu .eq. 1) .and. (nml .eq. -1)) ZemInd = 3
!if((nmu .eq. -1) .and. (nml .eq. 1)) ZemInd = 4
!if((nmu .eq. -1) .and. (nml .eq. -1)) ZemInd = 5
!if((nmu .eq. -3) .and. (nml .eq. -1)) ZemInd = 6
!return
!END FUNCTION ZemInd
!!==============================================================================

END MODULE abs_prof
